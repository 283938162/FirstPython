# coding:utf-8from selenium import webdriverimport time, osimport xlrd, xlwtfrom xlutils.copy import copyimport re'''测试爬取单个qq爬取并存入excel未抓取 设备名称，评论内容todo：增加判断 ifqq在线 直接使用快捷登录 click 这样可以避免验证码换用无头浏览器new see：selenium 因为要寻找下一页的网页元素  页面会自动向下翻动'''# 使用selenium# 使用selenium的隐藏PhantimJS浏览器登陆账号后对内容获取# 注意frame与iframe的格式框切换# driver = webdriver.PhantomJS(executable_path="/Users/anus/local/phantomjs-2.1.1-macosx/bin/phantomjs")driver = webdriver.Chrome()# driver.set_preference('network.proxy.type', 1)# driver.set_preference('network.proxy.http', '127.0.0.1')# driver.set_preference('network.proxy.http_port', 17890)driver.maximize_window()username = ''password = ''work_path = '/Users/anus/PycharmProjects/FirstPython/com/tlz/python-qq/data/qq.xls'qq_love_index_path = '/Users/anus/PycharmProjects/FirstPython/com/tlz/python-qq/data/qq_love_index.xls'values = []# 加头value_head = ['qq号码', 'qq昵称', '发表时间', '点赞数', '评论数', '说说内容']values.append(value_head)def get_shuoshuo(qq, path):    try:        # 设置等待网页加载的时间，直到抛出错误 time_to_wait:等待时间，以秒为单位        driver.set_page_load_timeout(10)        driver.get('http://user.qzone.qq.com/{}/311'.format(qq))        time.sleep(3)    except:        print(u'网页启动异常，请重新打开')        time.sleep(2)        driver.quit()    try:        driver.find_element_by_id('login_div')    except:        print("好友未向你开放空间权限,无法抓取内容")        driver.quit()    else:        driver.switch_to.frame('login_frame')        try:            # time.sleep(3)            # qq 在线的话 快速登录            print('检测到qq在线，快速登录')            face = driver.find_element_by_css_selector('.face').click()        except:            # 密码登录QQ空间            print('密码登录')            driver.find_element_by_id('switcher_plogin').click()            driver.find_element_by_id('u').clear()  # 选择用户名框            driver.find_element_by_id('u').send_keys(username)  # 输入个人登录账号            driver.find_element_by_id('p').clear()            driver.find_element_by_id('p').send_keys(password)  # 输入个人登录密码            driver.find_element_by_id('login_button').click()        time.sleep(3)    # 设置一个超时时间，隐式地等待元素的查找和命令的执行。每次会话中，这个函数只需要被调用一次。    driver.implicitly_wait(3)    # 有时候需要拖动验证码    time.sleep(4)    try:        driver.find_element_by_id('QM_OwnerInfo_Icon')    except:        print        u'空间加载异常，请重新打开'        time.sleep(2)        driver.quit()    else:        driver.switch_to.frame('app_canvas_frame')        #    last_page=driver.find_element_by_css_selector('.mod_pagenav')        #    page_num=re.findall('\d+',last_page.text)[-1]        next_page = 'page'        page = 1        # 设置一个超时时间，隐式地等待元素的查找和命令的执行。每次会话中，这个函数只需要被调用一次。        driver.implicitly_wait(1)  # 防止第一页抓空        try:            while next_page:                print(u'正在抓取第%d页面内容······' % page)                q_author = driver.find_elements_by_css_selector('.qz_311_author.c_tx.nickname.goProfile')                content = driver.find_elements_by_css_selector('.content')                stime = driver.find_elements_by_css_selector('.c_tx.c_tx3.goDetail')                # 因为该class 存在多个相同的值 不能使用常见的css选择器定位 可以通过下面 便签[属性值] 的方法来定位                # qz_like = driver.find_elements_by_css_selector('.qz_like_btn.c_tx.mr8'")                # qz_like = driver.find_elements_by_css_selector("input[class='qz_like_btn c_tx mr8'][_origtemp='赞{cnt}']")                qz_like = driver.find_elements_by_css_selector('a[_origtemp]')                qz_comment = driver.find_elements_by_css_selector('.c_tx.comment_btn')                # 发表设备 大多为空 不好并行迭代                # try:                #     custom_tail = driver.find_elements_by_css_selector('.custom-tail')                # except BaseException as e:                #     custom_tail = ''                # 并行迭代 里面的list必须不能为空                for aut, con, sti, li, ct in zip(q_author, content, stime, qz_like, qz_comment):                    # 字典                    # data = {                    #     'time': sti.text,                    #     'shuos': con.text                    # }                    #                    # qq = q_author.__getattribute__('data-uin')                    author = aut.text                    qqid = aut.get_attribute('data-uin')                    shuos = con.text                    times = sti.text                    # like = li.text                    # comment = ct.text                    # 提取点赞数和评论数                    # 在Python中，None、空列表[]、空字典{}、空元组()、0等一系列代表空和无的对象会被转换成False。除此之外的其它对象都会被转化成True                    if re.findall(r'\d+', li.text):                        like = re.findall(r'\d+', li.text)[0]                    else:                        like = 0                    if re.findall(r'\d+', ct.text):                        comment = re.findall(r'\d+', ct.text)[0]                    else:                        comment = 0                    # if custom_tail is None:                    #     tail = '未获取到该设备'                    # else:                    #     tail = ta.text                    # print(qq)                    # print(author)                    # print(times)                    # print(shuos)                    # print(like)                    # print(comment)                    # print(tail)                    value = []                    value.append(qqid)                    value.append(author)                    value.append(times)                    value.append(like)                    value.append(comment)                    value.append(shuos)                    print(value)                    # 构造一个二维list                    values.append(value)                    # print('times:' + times + '\t shuos:' + shuos)                    # write_data(data['time'], data['shuos'], path)                    # add_excel_data(times, shuos, path)                # 所有的driver.find xxx 返回的数据类型都是 WebElement 数据类型                next_page = driver.find_element_by_link_text(u'下一页')                page = page + 1                # python3 的格式化输出                # print(u'正在抓取第%d页面内容······' % page)                next_page.click()                # 如果把时间改成1s 会有重复                time.sleep(10)                driver.implicitly_wait(3)                # 只使用driver.implicitly_wait(3) 有时候会出现  翻页太多 抓取不到 必须sleep强制等待                # Message: stale element reference: element is not attached to the page document            driver.quit()        except BaseException as e:            # print(e)            print(u'抓取到%d页面结束' % page)            # print(values)            # save_values_toexcel(values, path, values[0][1])            # print('说说信息保存成功！')            # 抓取完数据 关闭浏览器            driver.quit()def testexist(path):    if not os.path.exists(path):        w = xlwt.Workbook()        w.add_sheet('Sheet1')        w.save(path)    else:        os.remove(path)        w = xlwt.Workbook()        w.add_sheet('Sheet1')        w.save(path)# def write03_excel(大厅):#     wb = xlwt.Workbook()  # 创建一个excel工作簿对象#     sheet = wb.add_sheet('测试2003excel')  # 用工作普对象新建一个sheet#     # 二维的excel表格 所以需要一个双层for循环#     # 确定行列树  i,j list元素下标#     for i in range(0, 4):#         for j in range(0, len(value[i])):#             sheet.write(i, j, value[i][j])  # 一个坐标放一个value##     wb.save(current_path)#     print('写入数据成功！')def write_data(data1, data2, path):    f = xlrd.open_workbook(path)    sheet = f.sheet_by_name('Sheet1')    src = copy(f)    row = sheet.nrows    src.get_sheet(0).write(row, 0, data1)    src.get_sheet(0).write(row, 1, data2)    src.save(path)# 逐条追加 效率低下def add_excel_data(times, shuos, path):    wb = xlrd.open_workbook(path)  # 用wlrd提供的方法读取一个excel文件    # sheets = wb.sheet_names()    # sheet = wb.sheet_by_name(sheets[0])    rows = wb.sheets()[0].nrows  # 用wlrd提供的方法获得现在已有的行数    new_wb = copy(wb)  # 用xlutils提供的copy方法将xlrd的对象转化为xlwt的对象    new_sheet = new_wb.get_sheet(0)  # 用xlwt对象的方法获得要操作的sheet  注意这个是（0） 不是[0]    # new_sheet.write(rows, 0, times)  # xlwt对象的写方法，参数分别是行、列、值    #    # new_sheet.write(rows, 1, shuos)    # 加说明头    if rows == 0:        new_sheet.write(0, 0, 'tims')  # xlwt对象的写方法，参数分别是行、列、值        new_sheet.write(0, 1, 'shuos')        new_sheet.write(rows + 1, 0, times)  # xlwt对象的写方法，参数分别是行、列、值        new_sheet.write(rows + 1, 1, shuos)    else:        new_sheet.write(rows, 0, times)  # xlwt对象的写方法，参数分别是行、列、值        new_sheet.write(rows, 1, shuos)    new_wb.save(path)  # xlwt对象的保存方法，这时便覆盖掉了原来的excel    # print('数据追加成功!')# 将所有的数据临时放到一个list的二维集合，抓取所有页面后 一次性写入def save_values_toexcel(values, path, sheetname):    wb = xlwt.Workbook()  # tab 自动没有（）    sheet = wb.add_sheet(sheetname)    rows = len(values)    cols = len(values[0])    for i in range(0, rows):        for j in range(0, cols):            sheet.write(i, j, values[i][j])    wb.save(path)def get_qq():    wb = xlrd.open_workbook(qq_love_index_path)    # sheet = wb.sheet_names()[0]     # 直接这种写 有问题的    sheets = wb.sheet_names()    sheet = wb.sheet_by_name(sheets[0])    rows = sheet.nrows    cols = sheet.ncols    for i in range(1, rows):        for j in range(0, 1):            # print(sheet.cell_value(i, j), '\t', end='')            print(sheet.cell_value(i, j))            qqid = sheet.cell_value(i, j)            get_shuoshuo(qqid, work_path)        # print()if __name__ == '__main__':    get_shuoshuo('1353154474', work_path)  # 输入好友QQ号    # work_path=raw_input(u'请输入存储数据路径--excle表格类型')2571278041    # 获取所有qq好友 亲密度    # get_friends(qq_love_index_path)    # 获取 指定qq号的说说信息    # 测试 追加写入excel模块    # add_excel_data(    # 测试 一次性写入excel模块    # values = [['a',    # save_values_toe